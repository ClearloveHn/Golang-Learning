# Golang圣经
## 1.切片(Slice)
### 1.1切片的定义
切片的底层是数组,slice是对数组的封装，他描述的是一个数组的片段。
### 1.2切片的底层构造原理
slice实际上是一个struct,包含三个字段:底层数组,长度,容量。  
```
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```
### 1.3数组和切片的异同
相同:两者都可通过下标来进行随机访问。  
不同:  
1.数组是定长的,切片是不定长的。  
2.数组的长度是其类型的一部分,切片不是。  
3.切片支持动态扩容。
### 1.4切片的注意事项
底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。
### 1.5切片的扩容
#### 1.5.1切片扩容场景
使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。
这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。
#### 1.5.2切片的扩容机制
Go1.18之前:  
当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。  

Go1.18之后:  
1.当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；  
2.原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4。  

注意：实际应用中并不是完全遵守以上规则,如果只看前半部分是相同的,但是后半部分,go会做内存对齐，内存对齐之后的新slice容量要大于等于前半部分生成的切片容量。
### 1.6切片作为函数参数
1.当 slice 作为函数参数时，就是一个普通的结构体。  
2.若直接传 slice, 实参slice并不会被函数中的操作改变；若传的是 slice 的指针，是会被函数中的操作改变原 slice 的。
3.不管传的是slice还是slice的指针,如果改变了 slice 底层数组的数据，会反应到实参slice 的底层数据。（比如s[1]=0这种操作）





