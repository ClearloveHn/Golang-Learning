# Golang圣经
## 1.切片(Slice)
### 1.1切片的定义
切片的底层是数组,slice是对数组的封装，他描述的是一个数组的片段。
### 1.2切片的底层构造原理
slice实际上是一个struct,包含三个字段:底层数组,长度,容量。  
```
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```
### 1.3数组和切片的异同
相同:两者都可通过下标来进行随机访问。  
不同:  
1.数组是定长的,切片是不定长的。  
2.数组的长度是其类型的一部分,切片不是。  
3.切片支持动态扩容。
### 1.4切片的注意事项
底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。
### 1.5切片的扩容
#### 1.5.1切片扩容场景
使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。
这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。
#### 1.5.2切片的扩容机制
Go1.18之前:  
当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。  

Go1.18之后:  
1.当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；  
2.原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4。  

注意：实际应用中并不是完全遵守以上规则,如果只看前半部分是相同的,但是后半部分,go会做内存对齐，内存对齐之后的新slice容量要大于等于前半部分生成的切片容量。
### 1.6切片作为函数参数
1.当 slice 作为函数参数时，就是一个普通的结构体。  
2.若直接传 slice, 实参slice并不会被函数中的操作改变；若传的是 slice 的指针，是会被函数中的操作改变原 slice 的。
3.不管传的是slice还是slice的指针,如果改变了 slice 底层数组的数据，会反应到实参slice 的底层数据。（比如s[1]=0这种操作）

## 2.Map
### 2.1Map的定义和作用
1.Map是由一组<key,value>对组成的数据结构,并且key只会出现一次。  
2.其作用设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。
### 2.2Map的底层实现
Golang中Map的底层实现是一个散列表,这个散列表中主要有两个结构体，一个叫hMap(表示map的结构体),一个叫bMap(bucket),其中bMap是在编译期间产生的。
### 2.3Map做为函数参数
1.当作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身。  
2.因为创建map的时候,底层调用了makeMap这个函数,这个函数的返回值是一个指针。
### 2.4Map的扩容
Golang Map的扩容时机:   
1.装载因子是否大于6.5  
2.overflow bucket是否过多  

扩容方法:  
1.双倍扩容:扩容采取了一种称为“渐进式”地方式，原有的key 并不会一次性搬迁完毕，每次最多只会搬迁 2个bucket。  
2.等量扩容：重新排列，极端情况下，重新排列也解决不了，map 成了链表，性能大大降低，此时哈希种子 hash0 的设置，可以降低此类极端场景的发生。  

装载因子(load factor):用于衡量当前哈希表中空间占用率的核心指标，也就是每个 bucket 桶存储的平均元素个数。
### 2.5为什么map遍历结果是无序
1.因为map中key是无序的    
2.如果map发生扩容,会发生 key 的搬迁,原来落在同一个 bucket 中的 key在搬迁后,有些 key 就要远走高飞了。但是遍历的过程是按顺序遍历 bucket,同时按顺序遍历 bucket 中的 key。
搬迁后，key 的位置发生了重大的变化,有些 key 飞上高枝，有些 key 则原地不动。这样,遍历 map 的结果就不可能按原来的顺序了。
3.Golang中遍历map并不是固定的从0号bucket开始遍历的，是随机选择bucket开始遍历,并且也是从这个bucket的一个随机序号的cell开始遍历。
### 2.6如何让map遍历结果有序
1.把key拿出来放入一个slice中,把slice进行排序  
2.利用官方库里的 list(链表) 封装一个结构体,实现一个有序的 K-V 存储结构,在里面维护一个 keys 的 list。
### 2.7map可以边遍历边删除吗
1.如果发生在多个协程同时读写一个map的情况下,如果被检测到,直接panic。  
2.如果在同一个协程内,理论上可以,但是遍历的结果可能不同。
### 2.8如何比较两个map是否相等
不能直接比较,只能遍历map的每个元素,比较元素是否深度相等。  
深度相等的条件:  
1.都为nil  
2.非空,长度相等,指向同一个map实体对象。  
3.相应的key指向的value深度相等。

## 3.接口(Interface)
### 3.1值接收者和指针接收者的区别
1.指针接收者方法会改变struct内部的数据。  
2.实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。
### 3.2iface和eface的区别
iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。  
### 3.3类型转换和断言的区别
1. 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。  
2. 类型断言代码实例
```
type Student struct {
	Name string
	Age int
}
func main() {
	var i interface{} = new(Student)
	s, ok := i.(Student) //<目标类型的值>，<布尔参数> := <表达式>.( 目标类型 )
	if ok {
		fmt.Println(s)
	}
}
```
### 3.4多态
多态是一种运行期的行为，它有以下几个特点：  
1.一种类型具有多种类型的能力。   
2.允许不同的对象对同一消息做出灵活的反应。    
3.以一种通用的方式对待个使用的对象。   
4.非动态语言必须通过继承和接口的方式来实现。   






